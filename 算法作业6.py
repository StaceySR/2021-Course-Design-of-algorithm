''''''
'''
1、情侣牵手

问题描述：N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。

一次交换可选择任意两人，让他们站起来交换座位。人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，
以此类推，最后一对是 (2N-2, 2N-1)。这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。

示例1：输入: row = [0, 2, 1, 3]    输出: 1     解释: 我们只需要交换row[1]和row[2]的位置即可。

示例2：输入: row = [3, 2, 0, 1]    输出: 0    解释: 无需交换座位，所有的情侣都已经可以手牵手了。
'''


def minSwapsCouples(row):
    # 贪心算法
    n = len(row)
    change = 0  # 记录交换的次数
    for i in range(0, n, 2):  # 遍历所有座位对的第一个人,（一对情侣占两个座位，从第一个作为开始占起，那么就只需要考虑0号、2号、4号。。他们右边是不是坐着自己的情侣即可）
        mate = row[i] ^ 1  # 它的另一半为当前值异或1即将最后一位取反，这能很好的实现（0，1）（2，3）（4，5）。。。这些情侣的相互配对，如1^1=0,0^1=1;2^1=3,3^1=2

        if row[i+1] != mate:  # 如果此时坐的不是它的另一半（座位对的第一人的后面一人，这俩人凑成情侣）
            j = i+2+row[i+2:].index(mate)  # 找到它的另一半，i+1肯定不是了，那直接从i+2找mate相对于i+2所在的位置，节省时间
            row[i+1], row[j] = row[j], row[i+1]  # 交换
            change += 1
    return change


row1 = [0, 2, 4, 1, 3, 5]  # 2和1交换、2和5交换
row2 = [0, 2, 1, 3]  # 2和1交换
row3 = [3, 2, 0, 1]  # 无需交换
row4 = [1, 4, 2, 3, 5, 0, 6, 9, 7, 8]  # 0和4交换、9和7交换

print(minSwapsCouples(row1))
print(minSwapsCouples(row2))
print(minSwapsCouples(row3))
print(minSwapsCouples(row4))



'''
2、分发糖果

问题描述：老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。
你需要按照以下要求，帮助老师给这些孩子分发糖果：（1）每个孩子至少分配到 1 个糖果；（2）相邻的孩子中，评分高的孩子必须获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

示例 1: 输入: [1,0,2]    输出: 5    解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。

示例 2: 输入: [1,2,2]    输出: 4    解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

'''


# （2）相邻的孩子中，评分高的孩子必须获得更多的糖果。
# 要满足（2）这条规则，只需要满足对于每个孩子来说，如果他的评分比左边相邻和右边相邻的孩子的高，那么就比他们的糖果数都要+1
def candy(ratings):
    # 从左到右遍历的记录数组
    left = [1 for _ in range(len(ratings))]  # （1）每个孩子至少一颗糖，首先给每人分发一颗
    # 从右到左遍历的记录数组
    right = left[:]

    for i in range(1, len(ratings)):  # 从左到右遍历孩子（直接可以从第二个孩子开始遍历（1号））
        if ratings[i] > ratings[i - 1]:  # 如果该孩子比左边相邻孩子评分高
            left[i] = left[i - 1] + 1  # 那么该孩子的糖果数比左边相邻孩子的糖果数+1
    count = left[-1]  # 在进入从右到左遍历之前，先对count糖果总数赋上最右边孩子的糖果数，因为从右到左遍历并不经过他
    for i in range(len(ratings) - 2, -1, -1):  # 从右到左遍历孩子（直接可以从倒数第二个孩子开始遍历（len(ratings) - 2号））
        if ratings[i] > ratings[i + 1]:   # 如果该孩子比右边相邻孩子评分高
            right[i] = right[i + 1] + 1  # 那么该孩子的糖果数比右边相邻孩子的糖果数+1
        count += max(left[i], right[i])  # count分别加上每个孩子最后拥有的糖果数。对于每个孩子来说，取从左到右遍历和从右到左遍历获得较大的糖果数
    return count


ratings1 = [1,0,2]
ratings2 = [1,2,2]
ratings3 = [5,7,8,3,4,2,1]
ratings4 = [3,2,6,1,8,4,2]
print('至少分发%d颗' % candy(ratings1))
print('至少分发%d颗' % candy(ratings2))
print('至少分发%d颗' % candy(ratings3))
print('至少分发%d颗' % candy(ratings4))




'''
3、跳跃游戏

问题描述：给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。
            你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例: 输入: [2,3,1,1,4]   输出: 2     解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，
                                            跳 1 步，然后跳 3 步到达数组的最后一个位置。

说明: 假设你总是可以到达数组的最后一个位置。
'''

# 题解
# 使用最少的步数到达最后一个位置，则第ii步位置为第i-1i−1步前的点中所能达到的最远位置。
#
# 贪心算法
# 定义步数step=0，能达到的最远位置max\_bound=0，和上一步到达的边界end=0。
# 遍历数组，遍历范围[0,n-1)：
#    所能达到的最远位置max\_bound=max(max\_bound,nums[i]+i)，表示上一最远位置和当前索引i和索引i上的步数之和中的较大者。
#    如果索引i到达了上一步的边界end，即i==end，则：
#       更新边界end，令end等于新的最远边界max\_bound，即end=max_bound
#       令步数step加一
# 返回step

# **注意！**数组遍历范围为[0,n-1)，因为当i==0时，step已经加一,所以若最后一个元素也遍历的话，当end恰好为n-1，步数会多1。
#
# 复杂度分析
# 时间复杂度：O(n)
# 空间复杂度：O(1)


def jump(nums):
    n = len(nums)
    if n < 2:
        return 0

    # 跳跃计数，初始值为1
    jump_num = 1

    max_dist = nums[0] + nums[nums[0]]  # 如果跳满num[i]，那么下一步能跳nums[nums[0]]
    border = nums[0]  # 每一次跳跃能到达的最大下标
    for i in range(n - 1):
        # 遍历到border之间的元素，在还没跳到border时，对于每一种跳法都进行尝试，看哪种最优
        # 产生新的最大跳跃边界
        max_dist = max(max_dist, i + nums[i])
        if i == border:  # 元素每次到达的最大跳跃的边界，那么就说明已经求出了这一条的最优跳法
            border = max_dist  # 则重新更新边界
            jump_num += 1  # 跳跃计数增加1

    return jump_num


num1 = [2,3,1,1,4]
num2 = [2,3,1,2,4,2,3]
num3 = [5,4,2,3,1,1,4]
num4 = [4,4,2,3,1,1,4]
print('跳到最后一个位置的最小跳跃数是', jump(num1))
print('跳到最后一个位置的最小跳跃数是', jump(num2))
print('跳到最后一个位置的最小跳跃数是', jump(num3))
print('跳到最后一个位置的最小跳跃数是', jump(num4))


'''
4、编程实现单源最短路径Dijkstra算法，并回答如果将图中所有边的权重+1，所得到的最短路径是否仍为原最短路径，为什么？

'''
# Dijkstra算法——通过边实现松弛
# 指定一个点到其他各顶点的路径——单源最短路径




# 每次找到离源点最近的一个顶点，然后以该顶点为重心进行扩展
# 最终的到源点到其余所有点的最短路径
# 一种贪婪算法

def Dijkstra(G, v0, INF=999):
    """ 使用 Dijkstra 算法计算指定点 v0 到图 G 中任意点的最短路径的距离
        INF 为设定的无限远距离值
        此方法不能解决负权值边的图
    """
    s = []  # 源顶点到该顶点的最短路径长度已知就加入s列表中
    minv = v0  # minv记录当前点

    # 源顶点到其余各顶点的初始路程都为无穷大
    dis = dict((k, INF) for k in G.keys())
    dis[v0] = 0  # 因为从v0点出发，所以dis【vo】=0

    while len(s) < len(G):
        s.append(minv)  # 确定当期顶点的距离
        for w in G[minv]:  # 以当前点的中心向外扩散
            if dis[minv] + G[minv][w] < dis[w]:  # 如果从当前点扩展到某一点的距离小与已知最短距离
                dis[w] = dis[minv] + G[minv][w]  # 对已知距离进行更新

        new = INF  # 从剩下的未确定点中选择最小距离点作为新的扩散点
        for v in dis.keys():
            if v in s:
                continue
            if dis[v] < new:
                new = dis[v]
                minv = v
    return dis


# 初始化图参数
G = {1: {1: 0,    2: 1,    3: 12},
     2: {2: 0,    3: 9,    4: 3},
     3: {3: 0,    5: 5},
     4: {3: 4,    4: 0,    5: 13,   6: 15},
     5: {5: 0,    6: 4},
     6: {6: 0}}
v0 = 1
dis = Dijkstra(G, v0)
print('从%d号点出发到其余各点的最短距离：' % v0, dis)

v0 = 2
dis = Dijkstra(G, v0)
print('从%d号点出发到其余各点的最短距离：' % v0, dis)

v0 = 3
dis = Dijkstra(G, v0)
print('从%d号点出发到其余各点的最短距离：' % v0, dis)





'''
5、证明题：请证明利用贪心算法构造的霍夫曼编码的正确性。
'''


